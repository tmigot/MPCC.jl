var documenterSearchIndex = {"docs":
[{"location":"api/#MPCC","page":"API","title":"MPCC","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MPCC.MPCCModelMeta\nMPCC.MPCCCounters\nMPCC.ADMPCCModel\nMPCC.BPMPCCModel\nMPCC.MPCCAmpl\nMPCC.MPCCNLPs\nMPCC.NLMPCC\nMPCC.MPCCAtX\nMPCC.MPCCStopping","category":"page"},{"location":"api/#MPCC.MPCCModelMeta","page":"API","title":"MPCC.MPCCModelMeta","text":"A composite type that represents the main features of the optimization problem\n\noptimize   obj(x)   subject to lvar ≤    x    ≤ uvar              lcon ≤ cons(x) ≤ ucon              lcc  ≤ G(x) | H(x) >= ucc\n\nwhere x        is an nvar-dimensional vector,        obj      is the real-valued objective function,        cons     is the vector-valued constraint function,        optimize is either \"minimize\" or \"maximize\".\n\nHere, lvar, uvar, lcon and ucon are vectors. Some of their  components may be infinite to indicate that the corresponding  bound or general constraint is not present.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCCounters","page":"API","title":"MPCC.MPCCCounters","text":"MPCCCounters\n\nInitialization: MPCCCounters()\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.NLMPCC","page":"API","title":"MPCC.NLMPCC","text":"Convert an MPCCModel to an NLPModels as follows. Definit le type NLMPCC : min \tf(x) s.t. \tl <= x <= u \tlcon(tb) <= cnl(x) <= ucon\n\nwith\n\ncnl(x) := c(x),G(x),H(x),G(x).*H(x)\n\n\n\n\n\n","category":"type"},{"location":"api/#General-Functions","page":"API","title":"General Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MPCC.WStat\nMPCC.CStat\nMPCC.MStat\nMPCC.SStat","category":"page"},{"location":"#MPCC-[Package-in-Dev]","page":"Home","title":"MPCC [Package in Dev]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MPCC.jl.","category":"page"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Set of tools to model the mathematical program with complementarity/switching/vanishing constraints. The package follows the same structure as the NLPModels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package contains the basic tools to use the Stopping framework.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"More to come...","category":"page"},{"location":"#TODO","page":"Home","title":"TODO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation/Further tests","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use the JuMP macro in Complementarity.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"MPCC reformulation from Bilevel optimization or GNEP","category":"page"},{"location":"tutorial/#Tutorials-and-examples","page":"Examples and tutorials","title":"Tutorials and examples","text":"","category":"section"}]
}
