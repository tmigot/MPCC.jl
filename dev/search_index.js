var documenterSearchIndex = {"docs":
[{"location":"api/#MPCC","page":"API","title":"MPCC","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MPCC.MPCCModelMeta\nMPCC.MPCCCounters\nMPCC.ADMPCCModel\nMPCC.BPMPCCModel\nMPCC.MPCCAmpl\nMPCC.MPCCNLPs\nMPCC.NLMPCC\nMPCC.MPCCAtX\nMPCC.MPCCStopping","category":"page"},{"location":"api/#MPCC.MPCCModelMeta","page":"API","title":"MPCC.MPCCModelMeta","text":"A composite type that represents the main features of the optimization problem\n\noptimize   obj(x)   subject to lvar ≤    x    ≤ uvar              lcon ≤ cons(x) ≤ ucon              lcc  ≤ G(x) | H(x) >= ucc\n\nwhere x        is an nvar-dimensional vector,        obj      is the real-valued objective function,        cons     is the vector-valued constraint function,        optimize is either \"minimize\" or \"maximize\".\n\nHere, lvar, uvar, lcon and ucon are vectors. Some of their  components may be infinite to indicate that the corresponding  bound or general constraint is not present.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCCounters","page":"API","title":"MPCC.MPCCCounters","text":"MPCCCounters\n\nInitialization: MPCCCounters()\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.NLMPCC","page":"API","title":"MPCC.NLMPCC","text":"Convert an MPCCModel to an NLPModels as follows. Definit le type NLMPCC : min \tf(x) s.t. \tl <= x <= u \tlcon(tb) <= cnl(x) <= ucon\n\nwith\n\ncnl(x) := c(x),G(x),H(x),G(x).*H(x)\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCAtX","page":"API","title":"MPCC.MPCCAtX","text":"Type: MPCCAtX Methods: update!, reinit!\n\nMPCCAtX contains the information concerning a nonlinear problem at the iteration x. min{x ∈ ℜⁿ} f(x) subject to lcon <= c(x) <= ucon, lvar <= x <= uvar, lG <= G(x) _| H(x) >= lH.\n\nBasic information is:\n\nx : the current candidate for solution to our original problem\nfx : which is the funciton evaluation at x\ngx : which is the gradient evaluation at x\nHx : which is the hessian representation at x\nmu : Lagrange multiplier of the bounds constraints\ncx : evaluation of the constraint function at x\nJx : jacobian matrix of the constraint function at x\nlambda : Lagrange multiplier of the constraints\ncurrent_time : time\nevals : number of evaluations of the function\n\nNote: * by default, unknown entries are set to nothing (except evals).       * All these information (except for x and lambda) are optionnal and need to be update when         required. The update is done trhough the update! function.       * x and lambda are mandatory entries. If no constraints lambda = [].       * The constructor check the size of the entries.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCStopping","page":"API","title":"MPCC.MPCCStopping","text":"Type: MPCCStopping (specialization of GenericStopping) Methods: start!, stop!, updateandstart!, updateandstop!, fill_in!, reinit!, status\n\nStopping structure for non-linear programming problems using NLPModels.     Input :        - pb         : an AbstractMPCCModel        - state      : The information relative to the problem, see GenericState        - (opt) meta : Metadata relative to stopping criterion, see StoppingMeta.        - (opt) mainstp : Stopping of the main loop in case we consider a Stopping                           of a subproblem.                           If not a subproblem, then nothing.        - (opt) listofstates : ListStates designed to store the history of States.        - (opt) userspecific_struct : Contains any structure designed by the user.\n\nMPCCStopping(:: AbstractMPCCModel, :: AbstractState; meta :: AbstractStoppingMeta = StoppingMeta(), main_stp :: Union{AbstractStopping, Nothing} = nothing, list :: Union{ListStates, Nothing} = nothing, user_specific_struct :: Any = nothing, kwargs...)\n\nNote:\n\noptimality_check : takes two inputs (AbstractMPCCModel, MPCCAtX)\n\nand returns a Float64 to be compared at 0.\n\ndesigned for MPCCAtX State. Constructor checks that the State has the\n\nrequired entries.\n\nWarning:\n\noptimality_check does not necessarily fill in the State.\n\n\n\n\n\n\n\n","category":"type"},{"location":"api/#General-Functions","page":"API","title":"General Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MPCC.WStat\nMPCC.CStat\nMPCC.MStat\nMPCC.SStat","category":"page"},{"location":"api/#MPCC.WStat","page":"API","title":"MPCC.WStat","text":"W-stationary check: WStat: verifies the Weak-stationary conditions required: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\nif complementarity: state.cGx, state.JGx, state.lambdaG                     state.cHx, state.JHx, state.lambdaH\n\n\n\n\n\n","category":"function"},{"location":"api/#MPCC.CStat","page":"API","title":"MPCC.CStat","text":"C-stationary check: Compute the score corresponding to: a) W-stationarity b) the correct sign of multipliers for indices I_00 by checking:          lambdaG .* lambdaH => 0 (i.e. max.(- state.lambdaG .* state.lambdaH, 0.0))\n\nrequired: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\nif complementarity: state.cGx, state.JGx, state.lambdaG                     state.cHx, state.JHx, state.lambdaH\n\n\n\n\n\n","category":"function"},{"location":"api/#MPCC.MStat","page":"API","title":"MPCC.MStat","text":"M-stationary check: Compute the score corresponding to: a) W-stationarity b) the correct sign of multipliers for indices I_00 by checking:          lambdaG .* lambdaH => 0 (i.e. max.(- state.lambdaG .* state.lambdaH, 0.0)) and          max(lambdaG, lambdaH) => 0 (i.e. max.(- max.(state.lambdaG, state.lambdaH), 0.0))\n\nrequired: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\nif complementarity: state.cGx, state.JGx, state.lambdaG                     state.cHx, state.JHx, state.lambdaH\n\n\n\n\n\n","category":"function"},{"location":"api/#MPCC.SStat","page":"API","title":"MPCC.SStat","text":"S-stationary check: Compute the score corresponding to: a) W-stationarity b) the correct sign of multipliers for indices I00 = { i : 0.5(Gi(x^)+H_i(x^)) <= actif }\n\nrequired: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\nif complementarity: state.cGx, state.JGx, state.lambdaG                     state.cHx, state.JHx, state.lambdaH\n\n\n\n\n\n","category":"function"},{"location":"#MPCC-[Package-in-Dev]","page":"Home","title":"MPCC [Package in Dev]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MPCC.jl.","category":"page"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Set of tools to model the mathematical program with complementarity/switching/vanishing constraints. The package follows the same structure as the NLPModels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package contains the basic tools to use the Stopping framework.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"More to come...","category":"page"},{"location":"#TODO","page":"Home","title":"TODO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation/Further tests","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use the JuMP macro in Complementarity.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"MPCC reformulation from Bilevel optimization or GNEP","category":"page"},{"location":"tutorial/#Tutorials-and-examples","page":"Examples and tutorials","title":"Tutorials and examples","text":"","category":"section"}]
}
