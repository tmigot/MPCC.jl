var documenterSearchIndex = {"docs":
[{"location":"api/#MPCC","page":"API","title":"MPCC","text":"","category":"section"},{"location":"api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MPCC.MPCCModelMeta\nMPCC.MPCCCounters\nMPCC.ADMPCCModel\nMPCC.BPMPCCModel\nMPCC.MPCCAmpl\nMPCC.MPCCNLPs\nMPCC.NLMPCC\nMPCC.MPCCAtX\nMPCC.MPCCStopping","category":"page"},{"location":"api/#MPCC.MPCCModelMeta","page":"API","title":"MPCC.MPCCModelMeta","text":"A composite type that represents the main features of the optimization problem\n\noptimize   obj(x)   subject to lvar ≤    x    ≤ uvar              lcon ≤ cons(x) ≤ ucon              lcc  ≤ G(x) | H(x) >= ucc\n\nwhere x        is an nvar-dimensional vector,        obj      is the real-valued objective function,        cons     is the vector-valued constraint function,        optimize is either \"minimize\" or \"maximize\".\n\nHere, lvar, uvar, lcon and ucon are vectors. Some of their  components may be infinite to indicate that the corresponding  bound or general constraint is not present.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCCounters","page":"API","title":"MPCC.MPCCCounters","text":"MPCCCounters\n\nInitialization: MPCCCounters()\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.ADMPCCModel","page":"API","title":"MPCC.ADMPCCModel","text":"ADMPCCModel is an AbstractMPCCModel using ForwardDiff to compute the derivatives. In this interface, the objective function f and an initial estimate are required. If there are constraints, the function cℝⁿ  ℝᵐ  and the vectors c_L and c_U also need to be passed. Bounds on the variables and an inital estimate to the Lagrangian multipliers can also be provided.\n\nADMPCCModel(f, x0; lvar = [-∞,…,-∞], uvar = [∞,…,∞], y0 = zeros,\n  c = NotImplemented, lcon = [-∞,…,-∞], ucon = [∞,…,∞], name = \"Generic\")\n\nf - The objective function f. Should be callable;\nx0 :: AbstractVector - The initial point of the problem;\nlvar :: AbstractVector - ℓ, the lower bound of the variables;\nuvar :: AbstractVector - u, the upper bound of the variables;\nc - The constraints function c. Should be callable;\ny0 :: AbstractVector - The initial value of the Lagrangian estimates;\nlcon :: AbstractVector - c_L, the lower bounds of the constraints function;\nucon :: AbstractVector - c_U, the upper bounds of the constraints function;\nname :: String - A name for the model.\n\nThe functions follow the same restrictions of ForwardDiff functions, summarised here:\n\nThe function can only be composed of generic Julia functions;\nThe function must accept only one argument;\nThe function's argument must accept a subtype of AbstractVector;\nThe function should be type-stable.\n\nFor contrained problems, the function c is required, and it must return an array even when m = 1, and c_L and c_U should be passed, otherwise the problem is ill-formed. For equality constraints, the corresponding index of c_L and c_U should be the same.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.BPMPCCModel","page":"API","title":"MPCC.BPMPCCModel","text":"This type convert a bilevel problem as an MPCCModel.\n\nBilevel Program:\n\nmin_{x,y} f1(x,y)\ns.t.  lcon    <= c(x)   <= ucon\n      lvar    <= x      <= uvar\n      y in argmin_{y} f2(x,y)\n                 s.t. ll_lcon <= g(x,y) <= ll_ucon (l1,  l2)\n                      ll_lvar <= y      <= ll_uvar (mu1, mu2)\n\nMPCC reformulation of the Bilevel Program:        min{x,y,l1,l2,mu1,mu2} f1(x,y)        s.t.  lvar <= x      <= uvar              lcon <= c(x)   <= ucon              0    <= ∇y f2(x,y) - ∇y g(x,y)' * (l1 - l2) - (mu1 - mu2) <= 0              G(x):=(  g(x,y)  - lllcon)                       llucon - g(x,y) )                       lluvar - y                       y - lllvar )              H(x):=( l1, l2, mu1, mu2 )              0 <= G(x) _| H(x) >= 0 ```` Gradient, Jacobian and Hessian are computed using automatic differentiation\n\nset nothirdderivative as true, to ignore the 3rd derivative of g.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCAmpl","page":"API","title":"MPCC.MPCCAmpl","text":"Definit le type MPCC : min f(x) l <= x <= u lb <= c(x) <= ub\n\nwith an array of integer \"cvar\" of the same size as c(x). cvar[i] is > 0 if ci(x) is involved in a complementarity constraint: (lbi = ci(x) or ci(x) = ub_i) OR x[cvar[i]] = 0.\n\nNote: cons(nlp, x) call twice cons(nlp.mp, x) [TO FIX - idem jac, hess]\n\nTODO: connect with https://github.com/tmigot/AmplNLReader.jl/blob/master/src/amplccmodel.jl\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCNLPs","page":"API","title":"MPCC.MPCCNLPs","text":"Definit le type MPCC : min f(x) l <= x <= u lb <= c(x) <= ub lccG <= G(x) | H(x) >= lccH\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.NLMPCC","page":"API","title":"MPCC.NLMPCC","text":"Convert an MPCCModel to an NLPModels as follows. Definit le type NLMPCC : min \tf(x) s.t. \tl <= x <= u \tlcon(tb) <= cnl(x) <= ucon\n\nwith\n\ncnl(x) := c(x),G(x),H(x),G(x).*H(x)\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCAtX","page":"API","title":"MPCC.MPCCAtX","text":"Type: MPCCAtX Methods: update!, reinit!\n\nMPCCAtX contains the information concerning a nonlinear problem at the iteration x. min{x ∈ ℜⁿ} f(x) subject to lcon <= c(x) <= ucon, lvar <= x <= uvar, lG <= G(x) _| H(x) >= lH.\n\nBasic information is:\n\nx : the current candidate for solution to our original problem\nfx : which is the funciton evaluation at x\ngx : which is the gradient evaluation at x\nHx : which is the hessian representation at x\nmu : Lagrange multiplier of the bounds constraints\ncx : evaluation of the constraint function at x\nJx : jacobian matrix of the constraint function at x\nlambda : Lagrange multiplier of the constraints\ncurrent_time : time\nevals : number of evaluations of the function\n\nNote: * by default, unknown entries are set to nothing (except evals).       * All these information (except for x and lambda) are optionnal and need to be update when         required. The update is done trhough the update! function.       * x and lambda are mandatory entries. If no constraints lambda = [].       * The constructor check the size of the entries.\n\n\n\n\n\n","category":"type"},{"location":"api/#MPCC.MPCCStopping","page":"API","title":"MPCC.MPCCStopping","text":"Type: MPCCStopping (specialization of GenericStopping) Methods: start!, stop!, updateandstart!, updateandstop!, fill_in!, reinit!, status\n\nStopping structure for non-linear programming problems using NLPModels.     Input :        - pb         : an AbstractMPCCModel        - optimalitycheck : a stopping criterion through an admissibility function        - state      : The information relative to the problem, see GenericState        - maxcntrs  : Dict contains the max number of evaluations        - (opt) meta : Metadata relative to stopping criterion.        - (opt) main_stp : Stopping of the main loop in case we consider a Stopping                           of a subproblem.                           If not a subproblem, then nothing.\n\nNote:\n\noptimality_check : takes two inputs (AbstractMPCCModel, MPCCAtX)\n\nand returns a Float64 to be compared at 0.\n\ndesigned for MPCCAtX State. Constructor checks that the State has the\n\nrequired entries.\n\nWarning:\n\noptimality_check does not necessarily fill in the State.\n\n\n\n\n\n\n\n","category":"type"},{"location":"api/#General-Functions","page":"API","title":"General Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"MPCC.WStat\nMPCC.CStat\nMPCC.MStat\nMPCC.SStat","category":"page"},{"location":"api/#MPCC.WStat","page":"API","title":"MPCC.WStat","text":"W-stationary check: WStat: verifies the Weak-stationary conditions required: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\nif complementarity: state.cGx, state.JGx, state.lambdaG                     state.cHx, state.JHx, state.lambdaH\n\n\n\n\n\n","category":"function"},{"location":"api/#MPCC.CStat","page":"API","title":"MPCC.CStat","text":"C-stationary check: Compute the score corresponding to: a) W-stationarity b) the correct sign of multipliers for indices I_00 by checking:          lambdaG .* lambdaH => 0 (i.e. max.(- state.lambdaG .* state.lambdaH, 0.0))\n\nrequired: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\nif complementarity: state.cGx, state.JGx, state.lambdaG                     state.cHx, state.JHx, state.lambdaH\n\n\n\n\n\n","category":"function"},{"location":"api/#MPCC.MStat","page":"API","title":"MPCC.MStat","text":"M-stationary check: Compute the score corresponding to: a) W-stationarity b) the correct sign of multipliers for indices I_00 by checking:          lambdaG .* lambdaH => 0 (i.e. max.(- state.lambdaG .* state.lambdaH, 0.0)) and          max(lambdaG, lambdaH) => 0 (i.e. max.(- max.(state.lambdaG, state.lambdaH), 0.0))\n\nrequired: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\nif complementarity: state.cGx, state.JGx, state.lambdaG                     state.cHx, state.JHx, state.lambdaH\n\n\n\n\n\n","category":"function"},{"location":"api/#MPCC.SStat","page":"API","title":"MPCC.SStat","text":"S-stationary check: Compute the score corresponding to: a) W-stationarity b) the correct sign of multipliers for indices I00 = { i : 0.5(Gi(x^)+H_i(x^)) <= actif }\n\nrequired: state.gx\n\nif bounds: state.mu\nif constraints: state.cx, state.Jx, state.lambda\nif complementarity: state.cGx, state.JGx, state.lambdaG                     state.cHx, state.JHx, state.lambdaH\n\n\n\n\n\n","category":"function"},{"location":"#MPCC-[Package-in-Dev]","page":"Home","title":"MPCC [Package in Dev]","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MPCC.jl.","category":"page"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Set of tools to model the mathematical program with complementarity/switching/vanishing constraints. The package follows the same structure as the NLPModels.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package contains the basic tools to use the Stopping framework.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"More to come...","category":"page"},{"location":"#TODO","page":"Home","title":"TODO","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation/Further tests","category":"page"},{"location":"","page":"Home","title":"Home","text":"Use the JuMP macro in Complementarity.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"MPCC reformulation from Bilevel optimization or GNEP","category":"page"},{"location":"tutorial/#Tutorials-and-examples","page":"Examples and tutorials","title":"Tutorials and examples","text":"","category":"section"}]
}
